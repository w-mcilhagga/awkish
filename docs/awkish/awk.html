<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>awkish.awk API documentation</title>
<meta name="description" content="Awk is a python class that can be used to do line-by-line processing
of files, inspired by awk. The Awk class can be imported using
```
from awkish â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>awkish.awk</code></h1>
</header>
<section id="section-intro">
<p>Awk is a python class that can be used to do line-by-line processing
of files, inspired by awk. The Awk class can be imported using</p>
<pre><code>from awkish import Awk
</code></pre>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="awkish.awk.Awk"><code class="flex name class">
<span>class <span class="ident">Awk</span></span>
<span>(</span><span>FS=re.compile(' +'), OFS=' ', RS='', ORS='\n')</span>
</code></dt>
<dd>
<div class="desc"><p>creates an instance of an awk-like program object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>FS</code></strong></dt>
<dd>the field separator. If a character, each line is split
using string.split(FS). If a regular expression object,
each line is split using FS.split(string). If a callable,
it is passed the line and returns a list of fields. The default is
to remove multiple spaces.</dd>
<dt><strong><code>OFS</code></strong></dt>
<dd>the output field separator</dd>
<dt><strong><code>RS</code></strong></dt>
<dd>the record separator, used as the newline parameter to an <code>open</code>
call. Default is '' which does not translate newlines when reading
or writing.</dd>
<dt><strong><code>ORS</code></strong></dt>
<dd>output record separator</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a callable Awk object. This can be used to process files by calling it. For
example</p>
<pre><code>from awkish import Awk
a = Awk()
# define actions
...
# call awk
ma(filename1, filename2, filename3)
</code></pre>
<p>will create a Awk object and run it over the three files named in
the call and dump any output to stdout. The parameters to the call are</p>
<ul>
<li><code>*filenames</code> - the names of the text files to process</li>
<li><code>output</code> - (optional) the name of the file to dump the program output</li>
<li><code>mode</code> - (optional) when <code>output</code> is specified, the open mode (defaults
to "wt")</li>
</ul>
<p>Thus, to put the output in <code>out.txt</code> and define an action argument x,
we would write</p>
<pre><code>ma(filename1, filename2, filename3, output=&quot;out.txt&quot;)
</code></pre></div>
<h3>Static methods</h3>
<dl>
<dt id="awkish.awk.Awk.CSV"><code class="name flex">
<span>def <span class="ident">CSV</span></span>(<span>line, strict=True)</span>
</code></dt>
<dd>
<div class="desc"><p>a field separator function, which can be used as the FS parameter
when creating a Awk object. This is <strong>not</strong> the same as setting FS to
a comma.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>line</code></strong></dt>
<dd>a string to be interpreted as one line of a CSV file.</dd>
<dt><strong><code>strict</code></strong></dt>
<dd>boolean to decide whether to raise an exception if the
line doesn't conform to RFC4180, default True</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a list of field strings. Escaped fields have quotes
removed and double quotes converted to single quotes.
This mostly follows RFC4180 except that quoted fields cannot contain
line breaks, as these are used by the file reader to break the file
into lines.</p>
<p>If the line does not conform to RFC4180, the function attempts to
find fields anyway if strict is False; it raises a ValueError otherwise.</p>
<p>Note that in the case of strict=False, to use as a FS in Awk it
has to be wrapped in a lambda, e.g.</p>
<pre><code>awk = Awk(FS=lambda line: Awk.CSV(line, strict=False))
</code></pre>
<p>Otherwise, it is enough to simply say <code>FS=Awk.CSV</code></p>
<h2 id="raises">Raises</h2>
<p>ValueError when strict is True and line isn't RFC4180 compatible</p></div>
</dd>
<dt id="awkish.awk.Awk.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>patt)</span>
</code></dt>
<dd>
<div class="desc"><p>a static method to create a condition function for finding a pattern string in a line</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>patt</code></strong></dt>
<dd>the pattern to search for</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a condition function which invokes line.find(patt). If the
pattern is found, it returns the index; otherwise it returns false
For example, if <code>a</code> is an Awk object, then</p>
<pre><code>a.when(Awk.find(&quot;abc&quot;))
def doline(self):
    ...
</code></pre>
<p>the decorated function <code>doline</code> will be called every time the line
contains the substring <code>"abc"</code>.</p></div>
</dd>
<dt id="awkish.awk.Awk.match"><code class="name flex">
<span>def <span class="ident">match</span></span>(<span>patt)</span>
</code></dt>
<dd>
<div class="desc"><p>a static method to create a condition function for matching a regex pattern in a line</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>patt</code></strong></dt>
<dd>the pattern to search for</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a condition function which invokes re.match(patt, line). It
returns the result of the match
For example, if <code>a</code> is an Awk object, then</p>
<pre><code>a.when(Awk.match(&quot;a+&quot;))
def doline(self):
    ...
</code></pre>
<p>the decorated function <code>doline</code> will be called every time
<code>re.match("a+",line)</code> succeeds.</p></div>
</dd>
<dt id="awkish.awk.Awk.search"><code class="name flex">
<span>def <span class="ident">search</span></span>(<span>patt)</span>
</code></dt>
<dd>
<div class="desc"><p>a static method to create a condition function for finding a regex pattern in a line</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>patt</code></strong></dt>
<dd>the pattern to search for</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a condition function which invokes re.search(patt, line). It
returns the result of the match</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="awkish.awk.Awk.all"><code class="name flex">
<span>def <span class="ident">all</span></span>(<span>self, f=None)</span>
</code></dt>
<dd>
<div class="desc"><p>a synonym for self.when(True)</p></div>
</dd>
<dt id="awkish.awk.Awk.begin"><code class="name flex">
<span>def <span class="ident">begin</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<div class="desc"><p>decorator for functions to be called before each file
is processed. This
does not work on methods.</p>
<p>For example, if <code>a</code> is a Awk object,</p>
<pre><code>@a.begin
def startfile(self):
    self.x = {}
</code></pre>
<p>then the startfile function will be called before processing any and every file.
Multiple functions can be decorated by <code>begin</code> and will be executed in turn
before processing any file.
The optional <code>self</code> argument to beginjob actions is the awk object with
the following additional properties:</p>
<ul>
<li><code>nr</code> - the number of records read in the job so far.</li>
<li><code>filename</code> - the name of the file being processed</li>
<li><code>nfr</code> - the number of records read in the file, which will be zero
when the function is called.</li>
</ul></div>
</dd>
<dt id="awkish.awk.Awk.beginjob"><code class="name flex">
<span>def <span class="ident">beginjob</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<div class="desc"><p>decorator for functions to be called before any files
are processed. This
does not work on methods.</p>
<p>For example, if <code>a</code> is a Awk object,</p>
<pre><code>@a.beginjob
def setup(self):
    self.x = {}
</code></pre>
<p>then the setup function will be called at the start of processing.
Multiple functions can be decorated by <code>beginjob</code> and will be executed in turn
at the start of processing.
The optional <code>self</code> argument to beginjob actions is the awk object with
the following additional properties:</p>
<ul>
<li><code>nr</code> - the number of records read in the job, which be zero
when the function is called.</li>
</ul></div>
</dd>
<dt id="awkish.awk.Awk.between"><code class="name flex">
<span>def <span class="ident">between</span></span>(<span>self, on_condition, off_condition)</span>
</code></dt>
<dd>
<div class="desc"><p>a range-matching decorator which selects all lines between an on condition
and an off condition occurring. This does not work on methods.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>on_condition</code></strong></dt>
<dd>a boolean or callable which determines whether the current line
starts the range. Any value
returned other than False or None is equivalent to True.
condition may be True, in which case all lines are processed.</dd>
<dt><strong><code>off_condition</code></strong></dt>
<dd>a boolean or callable which determines whether the current line
ends the range. Any value
returned other than False or None is equivalent to True.
condition may be True, in which case all lines are processed.
The line ending the range is still processed, because in awk, ranges
are inclusive.</dd>
</dl>
<p>For example, if <code>a</code> is a Awk object,</p>
<pre><code>@a.between(lambda self:self.nf==5, lambda self:self.nf==10)
def doline(self):
    print(self.line, end='')
</code></pre>
<p>then the <code>doline</code> action will be triggered for every line between the 5th and 10th inclusive.</p>
<p>This is <strong>not</strong> the same as <code>a.when(lambda self: self.nf&gt;=5 and self.nf&lt;=10)</code>. The <code>between</code>
will start processing when it finds a line with exactly 5 fields and end processing when it finds a line
with exactly 10 fields. The <code>when</code> will process all lines with between 5 and 10 fields.</p>
<p>The optional <code>self</code> argument to when actions and the condition is the awk object with
the following additional properties:</p>
<ul>
<li><code>nr</code> - the number of records read in the job so far.</li>
<li><code>filename</code> - the name of the file being processed</li>
<li><code>nfr</code> - the number of records read in the file so far.</li>
<li><code>line</code> - the entire line being processed, without the line ending</li>
<li><code>line_end</code> - the line ending</li>
<li><code>length</code> - the length of the line, equal to <code>len(line)</code></li>
<li><code>fields</code> - a list of fields parsed from the line</li>
<li><code>f0</code> - synonym for <code>line</code>, like awk's $0 variable</li>
<li><code>f1</code>, <code>f2</code>, &hellip; - the individual parsed fields (which are None if
they don't exist) like awk's $1, $2, &hellip; variables</li>
<li><code>nf</code> - the number of fields, equal to <code>len(fields)</code></li>
<li><code>result</code> - the result of the condition passed to <code>range</code>. When
the on_condition is first valid, result is the value.
When the off-condition is valid, result is the value.
In between, the result is True</li>
</ul></div>
</dd>
<dt id="awkish.awk.Awk.echo"><code class="name flex">
<span>def <span class="ident">echo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>echo <em>exactly</em> the line input, ignoring ORS</p></div>
</dd>
<dt id="awkish.awk.Awk.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<div class="desc"><p>decorator for functions to be called after each file
being processed. This does not work on methods.</p>
<p>For example, if <code>a</code> is a Awk object,</p>
<pre><code>@a.end
def afterfile(self):
    del self.x
</code></pre>
<p>then the afterfile function will be after processing each file.
Multiple functions can be decorated by endfile and will be executed in turn
after processing any file.
A function decorated by <code>end</code> can take the same argument as <code><a title="awkish.awk.Awk.begin" href="#awkish.awk.Awk.begin">Awk.begin()</a></code>.</p></div>
</dd>
<dt id="awkish.awk.Awk.endjob"><code class="name flex">
<span>def <span class="ident">endjob</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<div class="desc"><p>decorator for functions to be called after all files
are processed. This does not work on methods.</p>
<p>For example, if <code>a</code> is a Awk object,</p>
<pre><code>@a.endjob
def cleanup(self):
    del self.x
</code></pre>
<p>then the cleanup function will be called at the end of processing.
Multiple functions can be decorated by end and will be executed in turn
at the end of processing.
A function decorated by <code>endjob</code> can take the same argument as one
decorated by <code><a title="awkish.awk.Awk.beginjob" href="#awkish.awk.Awk.beginjob">Awk.beginjob()</a></code>.</p></div>
</dd>
<dt id="awkish.awk.Awk.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>print using defined <code>OFS</code> and <code>ORS</code> characters</p></div>
</dd>
<dt id="awkish.awk.Awk.when"><code class="name flex">
<span>def <span class="ident">when</span></span>(<span>self, condition)</span>
</code></dt>
<dd>
<div class="desc"><p>decorator for functions to be called during file processing. This
does not work on methods.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>condition</code></strong></dt>
<dd>a boolean or callable which determines whether the current line
should be passed to the decorated function. Any value
returned other than False or None is equivalent to True.
condition may be the boolean <code>True</code>, in which case all lines are processed.</dd>
</dl>
<p>For example, if <code>a</code> is a Awk object,</p>
<pre><code>@a.when(lambda self:self.line[0]=='$')
def doline(self):
    print(self.line)
</code></pre>
<p>then the <code>doline</code> action will be triggered for every line starting with $,
and print it.</p>
<p>The default action is <code>lambda self:self.print(self.line)</code> so the above could be
simplified to</p>
<pre><code>a.when(lambda self:self.line[0]=='$')()
</code></pre>
<p>If the condition is <code>True</code>, as here:</p>
<pre><code>@a.when(True)
def doline(self):
    print(self.line)
</code></pre>
<p>then the decorated action <code>doline</code> will be called for every line.</p>
<p>The optional <code>self</code> argument to when actions and the condition is the awk object with
the following additional properties:</p>
<ul>
<li><code>nr</code> - the number of records read in the job so far.</li>
<li><code>filename</code> - the name of the file being processed</li>
<li><code>nfr</code> - the number of records read in the file so far.</li>
<li><code>line</code> - the entire line being processed, without the line ending</li>
<li><code>line_end</code> - the line ending</li>
<li><code>fields</code> - a list of fields parsed from the line</li>
<li><code>f0</code> - synonym for <code>line</code>, like awk's $0 variable</li>
<li><code>f1</code>, <code>f2</code>, &hellip; - the individual parsed fields (which are None if
they don't exist) like awk's $1, $2, &hellip; variables</li>
<li><code>nf</code> - the number of fields, equal to <code>len(fields)</code></li>
<li><code>result</code> - the result of the condition passed to <code>when</code></li>
</ul></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="awkish" href="index.html">awkish</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="awkish.awk.Awk" href="#awkish.awk.Awk">Awk</a></code></h4>
<ul class="two-column">
<li><code><a title="awkish.awk.Awk.CSV" href="#awkish.awk.Awk.CSV">CSV</a></code></li>
<li><code><a title="awkish.awk.Awk.all" href="#awkish.awk.Awk.all">all</a></code></li>
<li><code><a title="awkish.awk.Awk.begin" href="#awkish.awk.Awk.begin">begin</a></code></li>
<li><code><a title="awkish.awk.Awk.beginjob" href="#awkish.awk.Awk.beginjob">beginjob</a></code></li>
<li><code><a title="awkish.awk.Awk.between" href="#awkish.awk.Awk.between">between</a></code></li>
<li><code><a title="awkish.awk.Awk.echo" href="#awkish.awk.Awk.echo">echo</a></code></li>
<li><code><a title="awkish.awk.Awk.end" href="#awkish.awk.Awk.end">end</a></code></li>
<li><code><a title="awkish.awk.Awk.endjob" href="#awkish.awk.Awk.endjob">endjob</a></code></li>
<li><code><a title="awkish.awk.Awk.find" href="#awkish.awk.Awk.find">find</a></code></li>
<li><code><a title="awkish.awk.Awk.match" href="#awkish.awk.Awk.match">match</a></code></li>
<li><code><a title="awkish.awk.Awk.print" href="#awkish.awk.Awk.print">print</a></code></li>
<li><code><a title="awkish.awk.Awk.search" href="#awkish.awk.Awk.search">search</a></code></li>
<li><code><a title="awkish.awk.Awk.when" href="#awkish.awk.Awk.when">when</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>